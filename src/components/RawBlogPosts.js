export const posts = [
  {
    id: 1,
    title: "You can make a Chrome extension!",
    body:
      "Inspired by this post by Lindsay Grizzard on how to make a simple Chrome extension, I decided to try my own.\nAccording to the docs over at developer.chrome.com an extension should be a small program with a single, narrow purpose. Extensions are used to customize the browsing experience.\nI started by following the beginning of Lindsay’s walkthrough to make an extension that renders a custom HTML page each time you open a new tab.\nI made a directory with an index.html file and a manifest.json file.\nEvery extension needs to have a manifest. It needs a name, description, version and manifest version. Manifest version should be set to ‘2.’ That’s the supported version right now. The other version is your project version number.\nchrome_url_overrides is what’s going to let us start customizing. For the basic walkthrough we just told each new tab to load our simple index.html.\nTo test it, we go to chrome://extensions and use the toggle in the upper right corner to switch to developer mode. Click “load unpacked” and select the extension directory. Now when I open a new tab I see the result of my index.html file.\nThat’s exciting, but I wanted to try something a little more fun.\nWith just one more file and a few more lines of code I made my extension trigger an alert on Twitter when you click the retweet button!\nFirst, I made a very simple index.js file that console.logs 'Hello Twitter' to make sure I'm connected.\nThen I made an addition to manifest.json.\nThe content scripts run on certain websites. Matches sets a match pattern. This one will match any URL with twitter.com in it. Then I specify the path to my new index.js file. After the updates were made and saved, I had return to Chrome developer mode and tell the extension to refresh so it would get those changes.\nThen, when I navigated to Twitter and checked the console to make sure index.js was connected.\nIt was! Next I spent some time poking around in the console. I practiced using querySelectorAll and getElementsByClassName to figure out how I was going to grab what I wanted to change.\nI ended up selecting the retweet buttons by class name. Then I turned them into an array so I could map over them and add event listeners that would trigger my alert on click.\nBack at the Chrome developer mode I refreshed again and headed back to Twitter and started trying to retweet things.\nIt works. It’s not ready for the Chrome Extension Store, but it’s fun to practice on!",
    date: "October 18, 2018",
    tags: ["JavaScript", "Chrome"],
    summary:
      "I made a simple extension that triggers an alert that asks ifyou're sure when you click a retweet button.",
    link:
      "https://aubreeabril.wordpress.com/2018/10/18/you-can-make-a-chrome-extension/"
  },
  {
    id: 2,
    title: "Hiding secret credentials in Rails",
    body:
      "I’ve tried to learn how to keep my API keys secret at some point during every Flatiron project I’ve done so far and failed and gave up. This time my partner and I got it to work and I wanted to save the whole process in one place for the next time I do this.\nRails 5.2 introduced the credentials file. You’ll find it in config/credentials.yml.env and it will look something like this.\nYou can hide your API keys and any other credentials that need to remain secret here, but as you can see, it’s encrypted, so you can’t edit it directly. You can run this command in your terminal:\n$ EDITOR=atom --wait rails credentials:edit\nYou can replace atom above with the name of your editor. This will open up a readable version of the file that you can edit. The file has a helpful commented out guide you can follow for formatting your secrets, but they should look something like this.\napi:\nid: 1234\nkey: 3456789\nIt’s easy to draw on these secrets later when you’re ready to use them.\nYour Rails app will also have a config/master.key file, which you should add to your .gitignore. This master key is used to encrypt and decrypt the credentials.\nOne wrinkle with this came up when my project partner cloned the project and tried to seed the database using our API keys. Since master.key was in the .gitignore file, she didn’t have that to decrypt the credentials file. So if a collaborator clones your project and needs to use your app’s credentials, they will need to create a master.key file that matches yours.\nHiding our API credentials this way caused us problems when we later deployed the app on Heroku (How to do that here). Since master.key was in our .gitignore, Heroku couldn’t get to the unencrypted version of our keys.\nTo fix it we saved our master.key to an environment variable. You can set a Heroku environment variable from the Heroku CLI by running:\nheroku config:set RAILS_MASTER_KEY=YOUR APP'S MASTER KEY\nI discovered later that you can also set up environment variables right on the Heroku dashboard for your application. Navigate to your application’s settings page and click the button that says Reveal Config Vars. You can add and edit your config variables here.\nAnd now you have an app that doesn’t reveal your API secrets!",
    date: "October 4, 2018",
    tags: ["Ruby"],
    summary:
      "I learned how to use credentials.yml to hide my API keys in Rails",
    link:
      "https://aubreeabril.wordpress.com/2018/10/04/hiding-secret-credentials-in-rails/"
  }
];
